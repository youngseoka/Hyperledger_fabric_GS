{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = dateParser;\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _toArray(arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n}\n\nfunction dateParser(date) {\n  var parsed = new Date(date);\n\n  if (!Number.isNaN(parsed.valueOf())) {\n    return parsed;\n  }\n\n  var parts = String(date).match(/\\d+/g);\n\n  if (parts == null || parts.length <= 2) {\n    return parsed;\n  } else {\n    var _parts$map = parts.map(function (x) {\n      return parseInt(x);\n    }),\n        _parts$map2 = _toArray(_parts$map),\n        firstP = _parts$map2[0],\n        secondP = _parts$map2[1],\n        restPs = _parts$map2.slice(2);\n\n    var correctedParts = [firstP, secondP - 1].concat(_toConsumableArray(restPs));\n    var isoDate = new Date(Date.UTC.apply(Date, _toConsumableArray(correctedParts)));\n    return isoDate;\n  }\n}","map":{"version":3,"sources":["/home/fabric/monitor_sk/fabric_explorer_nft/client/node_modules/react-timeago/lib/dateParser.js"],"names":["Object","defineProperty","exports","value","default","dateParser","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_toArray","date","parsed","Date","Number","isNaN","valueOf","parts","String","match","_parts$map","map","x","parseInt","_parts$map2","firstP","secondP","restPs","slice","correctedParts","concat","isoDate","UTC","apply"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,UAAlB;;AAEA,SAASC,kBAAT,CAA4BC,GAA5B,EAAiC;AAAE,MAAIC,KAAK,CAACC,OAAN,CAAcF,GAAd,CAAJ,EAAwB;AAAE,SAAK,IAAIG,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAGH,KAAK,CAACD,GAAG,CAACK,MAAL,CAA5B,EAA0CF,CAAC,GAAGH,GAAG,CAACK,MAAlD,EAA0DF,CAAC,EAA3D,EAA+D;AAAEC,MAAAA,IAAI,CAACD,CAAD,CAAJ,GAAUH,GAAG,CAACG,CAAD,CAAb;AAAmB;;AAAC,WAAOC,IAAP;AAAc,GAA7H,MAAmI;AAAE,WAAOH,KAAK,CAACK,IAAN,CAAWN,GAAX,CAAP;AAAyB;AAAE;;AAEnM,SAASO,QAAT,CAAkBP,GAAlB,EAAuB;AAAE,SAAOC,KAAK,CAACC,OAAN,CAAcF,GAAd,IAAqBA,GAArB,GAA2BC,KAAK,CAACK,IAAN,CAAWN,GAAX,CAAlC;AAAoD;;AAE7E,SAASF,UAAT,CAAoBU,IAApB,EAA0B;AACxB,MAAIC,MAAM,GAAG,IAAIC,IAAJ,CAASF,IAAT,CAAb;;AACA,MAAI,CAACG,MAAM,CAACC,KAAP,CAAaH,MAAM,CAACI,OAAP,EAAb,CAAL,EAAqC;AACnC,WAAOJ,MAAP;AACD;;AAED,MAAIK,KAAK,GAAGC,MAAM,CAACP,IAAD,CAAN,CAAaQ,KAAb,CAAmB,MAAnB,CAAZ;;AACA,MAAIF,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACT,MAAN,IAAgB,CAArC,EAAwC;AACtC,WAAOI,MAAP;AACD,GAFD,MAEO;AACL,QAAIQ,UAAU,GAAGH,KAAK,CAACI,GAAN,CAAU,UAAUC,CAAV,EAAa;AACtC,aAAOC,QAAQ,CAACD,CAAD,CAAf;AACD,KAFgB,CAAjB;AAAA,QAGIE,WAAW,GAAGd,QAAQ,CAACU,UAAD,CAH1B;AAAA,QAIIK,MAAM,GAAGD,WAAW,CAAC,CAAD,CAJxB;AAAA,QAKIE,OAAO,GAAGF,WAAW,CAAC,CAAD,CALzB;AAAA,QAMIG,MAAM,GAAGH,WAAW,CAACI,KAAZ,CAAkB,CAAlB,CANb;;AAQA,QAAIC,cAAc,GAAG,CAACJ,MAAD,EAASC,OAAO,GAAG,CAAnB,EAAsBI,MAAtB,CAA6B5B,kBAAkB,CAACyB,MAAD,CAA/C,CAArB;AACA,QAAII,OAAO,GAAG,IAAIlB,IAAJ,CAASA,IAAI,CAACmB,GAAL,CAASC,KAAT,CAAepB,IAAf,EAAqBX,kBAAkB,CAAC2B,cAAD,CAAvC,CAAT,CAAd;AACA,WAAOE,OAAP;AACD;AACF","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = dateParser;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\nfunction dateParser(date) {\n  var parsed = new Date(date);\n  if (!Number.isNaN(parsed.valueOf())) {\n    return parsed;\n  }\n\n  var parts = String(date).match(/\\d+/g);\n  if (parts == null || parts.length <= 2) {\n    return parsed;\n  } else {\n    var _parts$map = parts.map(function (x) {\n      return parseInt(x);\n    }),\n        _parts$map2 = _toArray(_parts$map),\n        firstP = _parts$map2[0],\n        secondP = _parts$map2[1],\n        restPs = _parts$map2.slice(2);\n\n    var correctedParts = [firstP, secondP - 1].concat(_toConsumableArray(restPs));\n    var isoDate = new Date(Date.UTC.apply(Date, _toConsumableArray(correctedParts)));\n    return isoDate;\n  }\n}"]},"metadata":{},"sourceType":"script"}