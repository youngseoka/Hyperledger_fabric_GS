{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _trackHelper = require('./trackHelper');\n\nvar _objectAssign = require('object-assign');\n\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar helpers = {\n  // supposed to start autoplay of slides\n  initialize: function initialize(props) {\n    var slickList = _reactDom2.default.findDOMNode(this.list);\n\n    var slideCount = _react2.default.Children.count(props.children);\n\n    var listWidth = this.getWidth(slickList);\n    var trackWidth = this.getWidth(_reactDom2.default.findDOMNode(this.track));\n    var slideWidth;\n\n    if (!props.vertical) {\n      var centerPaddingAdj = props.centerMode && parseInt(props.centerPadding) * 2;\n\n      if (props.centerPadding.slice(-1) === '%') {\n        centerPaddingAdj *= listWidth / 100;\n      }\n\n      slideWidth = (this.getWidth(_reactDom2.default.findDOMNode(this)) - centerPaddingAdj) / props.slidesToShow;\n    } else {\n      slideWidth = this.getWidth(_reactDom2.default.findDOMNode(this));\n    }\n\n    var slideHeight = this.getHeight(slickList.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * props.slidesToShow;\n    var currentSlide = props.rtl ? slideCount - 1 - props.initialSlide : props.initialSlide;\n    this.setState({\n      slideCount: slideCount,\n      slideWidth: slideWidth,\n      listWidth: listWidth,\n      trackWidth: trackWidth,\n      currentSlide: currentSlide,\n      slideHeight: slideHeight,\n      listHeight: listHeight\n    }, function () {\n      // this reference isn't lost due to mixin\n      var targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n        slideIndex: this.state.currentSlide,\n        trackRef: this.track\n      }, props, this.state)); // getCSS function needs previously set state\n\n      var trackStyle = (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({\n        left: targetLeft\n      }, props, this.state));\n      this.setState({\n        trackStyle: trackStyle\n      });\n      this.autoPlay(); // once we're set up, trigger the initial autoplay.\n    });\n  },\n  update: function update(props) {\n    var slickList = _reactDom2.default.findDOMNode(this.list); // This method has mostly same code as initialize method.\n    // Refactor it\n\n\n    var slideCount = _react2.default.Children.count(props.children);\n\n    var listWidth = this.getWidth(slickList);\n    var trackWidth = this.getWidth(_reactDom2.default.findDOMNode(this.track));\n    var slideWidth;\n\n    if (!props.vertical) {\n      var centerPaddingAdj = props.centerMode && parseInt(props.centerPadding) * 2;\n\n      if (props.centerPadding.slice(-1) === '%') {\n        centerPaddingAdj *= listWidth / 100;\n      }\n\n      slideWidth = (this.getWidth(_reactDom2.default.findDOMNode(this)) - centerPaddingAdj) / props.slidesToShow;\n    } else {\n      slideWidth = this.getWidth(_reactDom2.default.findDOMNode(this));\n    }\n\n    var slideHeight = this.getHeight(slickList.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * props.slidesToShow; // pause slider if autoplay is set to false\n\n    if (!props.autoplay) {\n      this.pause();\n    } else {\n      this.autoPlay();\n    }\n\n    this.setState({\n      slideCount: slideCount,\n      slideWidth: slideWidth,\n      listWidth: listWidth,\n      trackWidth: trackWidth,\n      slideHeight: slideHeight,\n      listHeight: listHeight\n    }, function () {\n      var targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n        slideIndex: this.state.currentSlide,\n        trackRef: this.track\n      }, props, this.state)); // getCSS function needs previously set state\n\n      var trackStyle = (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({\n        left: targetLeft\n      }, props, this.state));\n      this.setState({\n        trackStyle: trackStyle\n      });\n    });\n  },\n  getWidth: function getWidth(elem) {\n    return elem && (elem.getBoundingClientRect().width || elem.offsetWidth) || 0;\n  },\n  getHeight: function getHeight(elem) {\n    return elem && (elem.getBoundingClientRect().height || elem.offsetHeight) || 0;\n  },\n  adaptHeight: function adaptHeight() {\n    if (this.props.adaptiveHeight) {\n      var selector = '[data-index=\"' + this.state.currentSlide + '\"]';\n\n      if (this.list) {\n        var slickList = _reactDom2.default.findDOMNode(this.list);\n\n        var elem = slickList.querySelector(selector) || {};\n        slickList.style.height = (elem.offsetHeight || 0) + 'px';\n      }\n    }\n  },\n  canGoNext: function canGoNext(opts) {\n    var canGo = true;\n\n    if (!opts.infinite) {\n      if (opts.centerMode) {\n        // check if current slide is last slide\n        if (opts.currentSlide >= opts.slideCount - 1) {\n          canGo = false;\n        }\n      } else {\n        // check if all slides are shown in slider\n        if (opts.slideCount <= opts.slidesToShow || opts.currentSlide >= opts.slideCount - opts.slidesToShow) {\n          canGo = false;\n        }\n      }\n    }\n\n    return canGo;\n  },\n  slideHandler: function slideHandler(index) {\n    var _this = this; // index is target slide index\n    // Functionality of animateSlide and postSlide is merged into this function\n\n\n    var targetSlide, currentSlide;\n    var targetLeft, currentLeft;\n    var callback;\n\n    if (this.props.waitForAnimate && this.state.animating) {\n      return;\n    }\n\n    if (this.props.fade) {\n      currentSlide = this.state.currentSlide; // Don't change slide if infinite=false and target slide is out of range\n\n      if (this.props.infinite === false && (index < 0 || index >= this.state.slideCount)) {\n        return;\n      } //  Shifting targetSlide back into the range\n\n\n      if (index < 0) {\n        targetSlide = index + this.state.slideCount;\n      } else if (index >= this.state.slideCount) {\n        targetSlide = index - this.state.slideCount;\n      } else {\n        targetSlide = index;\n      }\n\n      if (this.props.lazyLoad && this.state.lazyLoadedList.indexOf(targetSlide) < 0) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(targetSlide)\n        });\n      }\n\n      callback = function callback() {\n        _this.setState({\n          animating: false\n        });\n\n        if (_this.props.afterChange) {\n          _this.props.afterChange(targetSlide);\n        }\n\n        delete _this.animationEndCallback;\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: targetSlide\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed);\n      });\n\n      if (this.props.beforeChange) {\n        this.props.beforeChange(this.state.currentSlide, targetSlide);\n      }\n\n      this.autoPlay();\n      return;\n    }\n\n    targetSlide = index;\n\n    if (targetSlide < 0) {\n      if (this.props.infinite === false) {\n        currentSlide = 0;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = this.state.slideCount - this.state.slideCount % this.props.slidesToScroll;\n      } else {\n        currentSlide = this.state.slideCount + targetSlide;\n      }\n    } else if (targetSlide >= this.state.slideCount) {\n      if (this.props.infinite === false) {\n        currentSlide = this.state.slideCount - this.props.slidesToShow;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = 0;\n      } else {\n        currentSlide = targetSlide - this.state.slideCount;\n      }\n    } else {\n      currentSlide = targetSlide;\n    }\n\n    targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n      slideIndex: targetSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n    currentLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n      slideIndex: currentSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n\n    if (this.props.infinite === false) {\n      if (targetLeft === currentLeft) {\n        targetSlide = currentSlide;\n      }\n\n      targetLeft = currentLeft;\n    }\n\n    if (this.props.beforeChange) {\n      this.props.beforeChange(this.state.currentSlide, currentSlide);\n    }\n\n    if (this.props.lazyLoad) {\n      var slidesToLoad = [];\n      var slideCount = this.state.slideCount;\n\n      for (var i = targetSlide; i < targetSlide + this.props.slidesToShow; i++) {\n        if (this.state.lazyLoadedList.indexOf(i) < 0) {\n          slidesToLoad.push(i);\n        }\n\n        if (i >= slideCount && this.state.lazyLoadedList.indexOf(i - slideCount) < 0) {\n          slidesToLoad.push(i - slideCount);\n        }\n\n        if (i < 0 && this.state.lazyLoadedList.indexOf(i + slideCount) < 0) {\n          slidesToLoad.push(i + slideCount);\n        }\n      }\n\n      if (slidesToLoad.length > 0) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(slidesToLoad)\n        });\n      }\n    } // Slide Transition happens here.\n    // animated transition happens to target Slide and\n    // non - animated transition happens to current Slide\n    // If CSS transitions are false, directly go the current slide.\n\n\n    if (this.props.useCSS === false) {\n      this.setState({\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({\n          left: currentLeft\n        }, this.props, this.state))\n      }, function () {\n        if (this.props.afterChange) {\n          this.props.afterChange(currentSlide);\n        }\n      });\n    } else {\n      var nextStateChanges = {\n        animating: false,\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({\n          left: currentLeft\n        }, this.props, this.state)),\n        swipeLeft: null\n      };\n\n      callback = function callback() {\n        _this.setState(nextStateChanges, function () {\n          if (_this.props.afterChange) {\n            _this.props.afterChange(currentSlide);\n          }\n\n          delete _this.animationEndCallback;\n        });\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackAnimateCSS)((0, _objectAssign2.default)({\n          left: targetLeft\n        }, this.props, this.state))\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed);\n      });\n    }\n\n    this.autoPlay();\n  },\n  swipeDirection: function swipeDirection(touchObject) {\n    var xDist, yDist, r, swipeAngle;\n    xDist = touchObject.startX - touchObject.curX;\n    yDist = touchObject.startY - touchObject.curY;\n    r = Math.atan2(yDist, xDist);\n    swipeAngle = Math.round(r * 180 / Math.PI);\n\n    if (swipeAngle < 0) {\n      swipeAngle = 360 - Math.abs(swipeAngle);\n    }\n\n    if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n      return 'left';\n    }\n\n    if (swipeAngle >= 135 && swipeAngle <= 225) {\n      return 'right';\n    }\n\n    if (this.props.verticalSwiping === true) {\n      if (swipeAngle >= 35 && swipeAngle <= 135) {\n        return 'down';\n      } else {\n        return 'up';\n      }\n    }\n\n    return 'vertical';\n  },\n  play: function play() {\n    var nextIndex;\n\n    if (!this.state.mounted) {\n      return false;\n    }\n\n    if (this.props.rtl) {\n      nextIndex = this.state.currentSlide - this.props.slidesToScroll;\n    } else {\n      if (this.canGoNext(_extends({}, this.props, this.state))) {\n        nextIndex = this.state.currentSlide + this.props.slidesToScroll;\n      } else {\n        return false;\n      }\n    }\n\n    this.slideHandler(nextIndex);\n  },\n  autoPlay: function autoPlay() {\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n    }\n\n    if (this.props.autoplay) {\n      this.setState({\n        autoPlayTimer: setTimeout(this.play, this.props.autoplaySpeed)\n      });\n    }\n  },\n  pause: function pause() {\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n      this.setState({\n        autoPlayTimer: null\n      });\n    }\n  }\n};\nexports.default = helpers;","map":{"version":3,"sources":["/fabric_explorer_nft/client/node_modules/react-slick/lib/mixins/helpers.js"],"names":["exports","__esModule","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_react","require","_react2","_interopRequireDefault","_reactDom","_reactDom2","_trackHelper","_objectAssign","_objectAssign2","obj","default","helpers","initialize","props","slickList","findDOMNode","list","slideCount","Children","count","children","listWidth","getWidth","trackWidth","track","slideWidth","vertical","centerPaddingAdj","centerMode","parseInt","centerPadding","slice","slidesToShow","slideHeight","getHeight","querySelector","listHeight","currentSlide","rtl","initialSlide","setState","targetLeft","getTrackLeft","slideIndex","state","trackRef","trackStyle","getTrackCSS","left","autoPlay","update","autoplay","pause","elem","getBoundingClientRect","width","offsetWidth","height","offsetHeight","adaptHeight","adaptiveHeight","selector","style","canGoNext","opts","canGo","infinite","slideHandler","index","_this","targetSlide","currentLeft","callback","waitForAnimate","animating","fade","lazyLoad","lazyLoadedList","indexOf","concat","afterChange","animationEndCallback","setTimeout","speed","beforeChange","slidesToScroll","slidesToLoad","push","useCSS","nextStateChanges","swipeLeft","getTrackAnimateCSS","swipeDirection","touchObject","xDist","yDist","r","swipeAngle","startX","curX","startY","curY","Math","atan2","round","PI","abs","verticalSwiping","play","nextIndex","mounted","autoPlayTimer","clearTimeout","autoplaySpeed"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _trackHelper = require('./trackHelper');\n\nvar _objectAssign = require('object-assign');\n\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar helpers = {\n  // supposed to start autoplay of slides\n  initialize: function initialize(props) {\n    var slickList = _reactDom2.default.findDOMNode(this.list);\n\n    var slideCount = _react2.default.Children.count(props.children);\n    var listWidth = this.getWidth(slickList);\n    var trackWidth = this.getWidth(_reactDom2.default.findDOMNode(this.track));\n    var slideWidth;\n\n    if (!props.vertical) {\n      var centerPaddingAdj = props.centerMode && parseInt(props.centerPadding) * 2;\n      if (props.centerPadding.slice(-1) === '%') {\n        centerPaddingAdj *= listWidth / 100;\n      }\n      slideWidth = (this.getWidth(_reactDom2.default.findDOMNode(this)) - centerPaddingAdj) / props.slidesToShow;\n    } else {\n      slideWidth = this.getWidth(_reactDom2.default.findDOMNode(this));\n    }\n\n    var slideHeight = this.getHeight(slickList.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * props.slidesToShow;\n\n    var currentSlide = props.rtl ? slideCount - 1 - props.initialSlide : props.initialSlide;\n\n    this.setState({\n      slideCount: slideCount,\n      slideWidth: slideWidth,\n      listWidth: listWidth,\n      trackWidth: trackWidth,\n      currentSlide: currentSlide,\n      slideHeight: slideHeight,\n      listHeight: listHeight\n    }, function () {\n      // this reference isn't lost due to mixin\n      var targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n        slideIndex: this.state.currentSlide,\n        trackRef: this.track\n      }, props, this.state));\n      // getCSS function needs previously set state\n      var trackStyle = (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({ left: targetLeft }, props, this.state));\n\n      this.setState({ trackStyle: trackStyle });\n\n      this.autoPlay(); // once we're set up, trigger the initial autoplay.\n    });\n  },\n  update: function update(props) {\n    var slickList = _reactDom2.default.findDOMNode(this.list);\n    // This method has mostly same code as initialize method.\n    // Refactor it\n    var slideCount = _react2.default.Children.count(props.children);\n    var listWidth = this.getWidth(slickList);\n    var trackWidth = this.getWidth(_reactDom2.default.findDOMNode(this.track));\n    var slideWidth;\n\n    if (!props.vertical) {\n      var centerPaddingAdj = props.centerMode && parseInt(props.centerPadding) * 2;\n      if (props.centerPadding.slice(-1) === '%') {\n        centerPaddingAdj *= listWidth / 100;\n      }\n      slideWidth = (this.getWidth(_reactDom2.default.findDOMNode(this)) - centerPaddingAdj) / props.slidesToShow;\n    } else {\n      slideWidth = this.getWidth(_reactDom2.default.findDOMNode(this));\n    }\n\n    var slideHeight = this.getHeight(slickList.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * props.slidesToShow;\n\n    // pause slider if autoplay is set to false\n    if (!props.autoplay) {\n      this.pause();\n    } else {\n      this.autoPlay();\n    }\n\n    this.setState({\n      slideCount: slideCount,\n      slideWidth: slideWidth,\n      listWidth: listWidth,\n      trackWidth: trackWidth,\n      slideHeight: slideHeight,\n      listHeight: listHeight\n    }, function () {\n\n      var targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n        slideIndex: this.state.currentSlide,\n        trackRef: this.track\n      }, props, this.state));\n      // getCSS function needs previously set state\n      var trackStyle = (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({ left: targetLeft }, props, this.state));\n\n      this.setState({ trackStyle: trackStyle });\n    });\n  },\n  getWidth: function getWidth(elem) {\n    return elem && (elem.getBoundingClientRect().width || elem.offsetWidth) || 0;\n  },\n  getHeight: function getHeight(elem) {\n    return elem && (elem.getBoundingClientRect().height || elem.offsetHeight) || 0;\n  },\n\n  adaptHeight: function adaptHeight() {\n    if (this.props.adaptiveHeight) {\n      var selector = '[data-index=\"' + this.state.currentSlide + '\"]';\n      if (this.list) {\n        var slickList = _reactDom2.default.findDOMNode(this.list);\n        var elem = slickList.querySelector(selector) || {};\n        slickList.style.height = (elem.offsetHeight || 0) + 'px';\n      }\n    }\n  },\n  canGoNext: function canGoNext(opts) {\n    var canGo = true;\n    if (!opts.infinite) {\n      if (opts.centerMode) {\n        // check if current slide is last slide\n        if (opts.currentSlide >= opts.slideCount - 1) {\n          canGo = false;\n        }\n      } else {\n        // check if all slides are shown in slider\n        if (opts.slideCount <= opts.slidesToShow || opts.currentSlide >= opts.slideCount - opts.slidesToShow) {\n          canGo = false;\n        }\n      }\n    }\n    return canGo;\n  },\n  slideHandler: function slideHandler(index) {\n    var _this = this;\n\n    // index is target slide index\n\n    // Functionality of animateSlide and postSlide is merged into this function\n    var targetSlide, currentSlide;\n    var targetLeft, currentLeft;\n    var callback;\n\n    if (this.props.waitForAnimate && this.state.animating) {\n      return;\n    }\n\n    if (this.props.fade) {\n      currentSlide = this.state.currentSlide;\n\n      // Don't change slide if infinite=false and target slide is out of range\n      if (this.props.infinite === false && (index < 0 || index >= this.state.slideCount)) {\n        return;\n      }\n\n      //  Shifting targetSlide back into the range\n      if (index < 0) {\n        targetSlide = index + this.state.slideCount;\n      } else if (index >= this.state.slideCount) {\n        targetSlide = index - this.state.slideCount;\n      } else {\n        targetSlide = index;\n      }\n\n      if (this.props.lazyLoad && this.state.lazyLoadedList.indexOf(targetSlide) < 0) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(targetSlide)\n        });\n      }\n\n      callback = function callback() {\n        _this.setState({\n          animating: false\n        });\n        if (_this.props.afterChange) {\n          _this.props.afterChange(targetSlide);\n        }\n        delete _this.animationEndCallback;\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: targetSlide\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed);\n      });\n\n      if (this.props.beforeChange) {\n        this.props.beforeChange(this.state.currentSlide, targetSlide);\n      }\n\n      this.autoPlay();\n      return;\n    }\n\n    targetSlide = index;\n    if (targetSlide < 0) {\n      if (this.props.infinite === false) {\n        currentSlide = 0;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = this.state.slideCount - this.state.slideCount % this.props.slidesToScroll;\n      } else {\n        currentSlide = this.state.slideCount + targetSlide;\n      }\n    } else if (targetSlide >= this.state.slideCount) {\n      if (this.props.infinite === false) {\n        currentSlide = this.state.slideCount - this.props.slidesToShow;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = 0;\n      } else {\n        currentSlide = targetSlide - this.state.slideCount;\n      }\n    } else {\n      currentSlide = targetSlide;\n    }\n\n    targetLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n      slideIndex: targetSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n\n    currentLeft = (0, _trackHelper.getTrackLeft)((0, _objectAssign2.default)({\n      slideIndex: currentSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n\n    if (this.props.infinite === false) {\n      if (targetLeft === currentLeft) {\n        targetSlide = currentSlide;\n      }\n      targetLeft = currentLeft;\n    }\n\n    if (this.props.beforeChange) {\n      this.props.beforeChange(this.state.currentSlide, currentSlide);\n    }\n\n    if (this.props.lazyLoad) {\n      var slidesToLoad = [];\n      var slideCount = this.state.slideCount;\n      for (var i = targetSlide; i < targetSlide + this.props.slidesToShow; i++) {\n        if (this.state.lazyLoadedList.indexOf(i) < 0) {\n          slidesToLoad.push(i);\n        }\n        if (i >= slideCount && this.state.lazyLoadedList.indexOf(i - slideCount) < 0) {\n          slidesToLoad.push(i - slideCount);\n        }\n        if (i < 0 && this.state.lazyLoadedList.indexOf(i + slideCount) < 0) {\n          slidesToLoad.push(i + slideCount);\n        }\n      }\n      if (slidesToLoad.length > 0) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(slidesToLoad)\n        });\n      }\n    }\n\n    // Slide Transition happens here.\n    // animated transition happens to target Slide and\n    // non - animated transition happens to current Slide\n    // If CSS transitions are false, directly go the current slide.\n\n    if (this.props.useCSS === false) {\n\n      this.setState({\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({ left: currentLeft }, this.props, this.state))\n      }, function () {\n        if (this.props.afterChange) {\n          this.props.afterChange(currentSlide);\n        }\n      });\n    } else {\n\n      var nextStateChanges = {\n        animating: false,\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackCSS)((0, _objectAssign2.default)({ left: currentLeft }, this.props, this.state)),\n        swipeLeft: null\n      };\n      callback = function callback() {\n        _this.setState(nextStateChanges, function () {\n          if (_this.props.afterChange) {\n            _this.props.afterChange(currentSlide);\n          }\n          delete _this.animationEndCallback;\n        });\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackAnimateCSS)((0, _objectAssign2.default)({ left: targetLeft }, this.props, this.state))\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed);\n      });\n    }\n\n    this.autoPlay();\n  },\n  swipeDirection: function swipeDirection(touchObject) {\n    var xDist, yDist, r, swipeAngle;\n\n    xDist = touchObject.startX - touchObject.curX;\n    yDist = touchObject.startY - touchObject.curY;\n    r = Math.atan2(yDist, xDist);\n\n    swipeAngle = Math.round(r * 180 / Math.PI);\n    if (swipeAngle < 0) {\n      swipeAngle = 360 - Math.abs(swipeAngle);\n    }\n    if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n      return 'left';\n    }\n    if (swipeAngle >= 135 && swipeAngle <= 225) {\n      return 'right';\n    }\n    if (this.props.verticalSwiping === true) {\n      if (swipeAngle >= 35 && swipeAngle <= 135) {\n        return 'down';\n      } else {\n        return 'up';\n      }\n    }\n\n    return 'vertical';\n  },\n  play: function play() {\n    var nextIndex;\n\n    if (!this.state.mounted) {\n      return false;\n    }\n\n    if (this.props.rtl) {\n      nextIndex = this.state.currentSlide - this.props.slidesToScroll;\n    } else {\n      if (this.canGoNext(_extends({}, this.props, this.state))) {\n        nextIndex = this.state.currentSlide + this.props.slidesToScroll;\n      } else {\n        return false;\n      }\n    }\n\n    this.slideHandler(nextIndex);\n  },\n  autoPlay: function autoPlay() {\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n    }\n    if (this.props.autoplay) {\n      this.setState({\n        autoPlayTimer: setTimeout(this.play, this.props.autoplaySpeed)\n      });\n    }\n  },\n  pause: function pause() {\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n      this.setState({\n        autoPlayTimer: null\n      });\n    }\n  }\n};\n\nexports.default = helpers;"]},"metadata":{},"sourceType":"script"}